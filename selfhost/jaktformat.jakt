// Copyright (c) 2022, Jannis Adamek <jannis.adamek@gmail.com>
//
// SPDX-License-Identifier: BSD-2-Clause

import compiler {Compiler}
import lexer {Lexer, Token}
import utility {FilePath, ArgsParser, panic}
import parser {Parser, ParsedFunction, ParsedParameter, ParsedType, ParsedModuleImport, ImportName}

function usage(program_name: String) throws => format("usage: {} <filename>", program_name)

struct Context {
    indentation: u32
}

function module_import_to_string(parsed_module_import: ParsedModuleImport) throws -> String {
    mut output = format("import {}", parsed_module_import.module_name.name)
    if parsed_module_import.alias_name.has_value() {
        output += format(" as {}", parsed_module_import.alias_name!)
    }
    if parsed_module_import.import_list.size() != 0 {
        output += " { "
        for i in 0..parsed_module_import.import_list.size() {
            let import_name = parsed_module_import.import_list[i]
            output += import_name.name
            if i < parsed_module_import.import_list.size()-1 {
                output += ", "
            }
        }
        output += " }"
    }
    return output
}

function type_to_string(parsed_type: ParsedType) throws -> String => match parsed_type {
    Name(name) => name
    NamespacedName(name, namespaces, params) => {
        mut output = ""
        for i in 0..namespaces.size() {
            let parsed_type = namespaces[i]
            output += parsed_type
            if i < namespaces.size()-1 {
                output += "::"
            }
        }
        if params.size() != 0 {
            output += "<"
            for i in 0..params.size() {
                let parsed_type = params[i]
                output += type_to_string(parsed_type)
                if i < params.size()-1 {
                    output += ", "
                }
            }
            output += ">"
        }
        yield output + ">"
    }
    GenericType(name, generic_parameters) => {
        mut output = format("{}<", name)
        for i in 0..generic_parameters.size() {
            let parsed_type = generic_parameters[i]
            output += type_to_string(parsed_type)
            if i < generic_parameters.size()-1 {
                output += ", "
            }
        }
        yield output + ">"
    }
    JaktArray(inner) => format("[{}]", type_to_string(parsed_type: inner))
    Dictionary(key, value) => format("[{}:{}]", type_to_string(parsed_type: key), type_to_string(parsed_type: value))
    JaktTuple(types) => {
        mut output = "("
        for i in 0..types.size() {
            let parsed_type = types[i]
            output += type_to_string(parsed_type)
            if i < types.size()-1 {
                output += ", "
            }
        }
        yield output + ")"
    }
    Set(inner) => format("{{}}", type_to_string(parsed_type: inner))
    Optional(inner) => format("{}?", type_to_string(parsed_type: inner))
    Reference(inner) => format("&{}", type_to_string(parsed_type: inner))
    MutableReference(inner) => format("&mut {}", type_to_string(parsed_type: inner))
    RawPtr(inner) => format("raw {}", type_to_string(parsed_type: inner))
    WeakPtr(inner) => format("weak {}?", type_to_string(parsed_type: inner))
    Function(params, can_throw, return_type) => {
        mut fn = format(
            "function ({})"
            param_list_to_string(parsed_parameters: params)
        )
        if can_throw {
            fn += " throws"
        }
        fn += format(" -> {}", return_type)
        yield fn
    }
    Empty => "void" //FIXME void should not be enforced, omitted types should stay omitted
}


function param_list_to_string(parsed_parameters: [ParsedParameter]) throws -> String {
    mut output = ""
    for i in 0..parsed_parameters.size() {
        let param = parsed_parameters[i]
        let type = type_to_string(parsed_type: param.variable.parsed_type)
        output += format("{}: {}", param.variable.name, type)
        if i < parsed_parameters.size()-1 {
            output += ", "
        }
    }
    return output
}

function function_to_string(parsed_function: ParsedFunction) throws -> String {
    mut output = ""
    
    output += format(
        "function {}({})",
        parsed_function.name,
        param_list_to_string(parsed_parameters: parsed_function.params)
    )

    if parsed_function.can_throw {
        output += " throws"
    }
    output += format(" -> {}", type_to_string(parsed_type: parsed_function.return_type))

    return output
}

function main(args: [String]) {
    mut compiler = Compiler(
        files: []
        file_ids: [:]
        errors: []
        current_file: None
        current_file_contents: []
        dump_lexer: true
        dump_parser: false
        ignore_parser_errors: false
        debug_print: false
        include_paths: []
        json_errors: false
        dump_type_hints: false
        dump_try_hints: false
    )

    let args_parser = ArgsParser::from_args(args)
    let positional_arguments = args_parser.remaining_arguments()

    let program_name = args[0]

    if (positional_arguments.size() != 2) {
        eprintln("{}", usage(program_name))
        return 1
    }

    let file_path = args[1]

    let main_file_id = compiler.get_file_id_or_register(FilePath::make(file_path))
    let file_is_set = compiler.set_current_file(main_file_id)
    if not file_is_set {
        return 1
    }

    let tokens = Lexer::lex(compiler, include_whitespace: false)
    let result = Parser::parse(compiler, tokens)

    for m in result.module_imports.iterator() {
        println("{}", module_import_to_string(parsed_module_import: m))
    }
    for f in result.functions.iterator() {
        println("{}", function_to_string(parsed_function: f))
    }
}
